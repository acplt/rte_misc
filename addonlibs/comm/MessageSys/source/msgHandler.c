
/******************************************************************************
*
*   FILE
*   ----
*   msgHandler.c
*
*   History
*   -------
*   2013-11-07   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_MessageSys
#define OV_COMPILE_LIBRARY_MessageSys
#endif


#include "MessageSys.h"
#include "libov/ov_macros.h"
#include "ks_logfile.h"
#include "acplt_simpleMsgHandling.h"
#include "MessageSys_helpers.h"
#include <stdlib.h>
#include <strings.h>

OV_DLLFNCEXPORT void MessageSys_msgHandler_startup(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
//    OV_INSTPTR_MessageSys_msgHandler pinst = Ov_StaticPtrCast(MessageSys_msgHandler, pobj);

    /* do what the base class does first */
    ksbase_ClientHandler_startup(pobj);

    /* do what */


    return;
}

OV_DLLFNCEXPORT void MessageSys_msgHandler_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
//    OV_INSTPTR_MessageSys_msgHandler pinst = Ov_StaticPtrCast(MessageSys_msgHandler, pobj);

    /* do what */

    /* set the object's state to "shut down" */
    ksbase_ClientHandler_shutdown(pobj);

    return;
}

OV_DLLFNCEXPORT OV_RESULT MessageSys_msgHandler_HandleRequest(
	OV_INSTPTR_ksbase_ClientHandler this,
	KS_DATAPACKET* dataReceived,
	KS_DATAPACKET* answer
) {
    /*    
    *   local variables
    */
	OV_STRING msgString = NULL;
	OV_STRING tempData = NULL;
	OV_UINT i;
	OV_UINT msgTagLength;
	OV_UINT msgLength;
	OV_UINT hdrLength;
	OV_UINT bdyLength;
	OV_INSTPTR_MessageSys_Message	pNewMessage =	NULL;
	OV_INSTPTR_ov_domain			pInbox 		=	NULL;
	OV_ELEMENT						InboxElem;
	OV_ELEMENT						VarElem;
	OV_INSTPTR_ksbase_Channel		pChannel	=	NULL;

	pChannel = Ov_GetParent(ksbase_AssocChannelClientHandler, this);

	/***********************************************************************************************************************************************************************************************
	 *	Check if message is complete in buffer. if not, return ERR_OK and wait for a short time. is the message has not arrived completely within a second we assume it is broken
	 ***********************************************************************************************************************************************************************************************/

	if((dataReceived->length - (dataReceived->readPT - dataReceived->data)) < 19)
	{
		KS_logfile_debug(("%s: HandleRequest: Buffer does NOT hold the complete request. waiting some time...", this->v_identifier));
		pChannel->v_ConnectionTimeOut = 2;
		return OV_ERR_OK;		/*	get called again to process the request next time (if it is complete then).
													Yes, this could block the ClientHandler for a longer time.	*/
	}
	ov_memstack_lock();
	msgString = ov_memstack_alloc(dataReceived->length - (dataReceived->readPT - dataReceived->data) + 1);
	/*	just copy until end of tag	*/
	for(i=0; i<dataReceived->length && dataReceived->readPT[i-1] != '>'; i++)
		msgString[i] = dataReceived->readPT[i];
	msgString[i] = '\0';
	msgTagLength = i;
	/*	check if message is valid	*/
	acplt_simpleMsg_xml_findElementBegin(msgString, "msg", &tempData);
	if(!tempData)
	{
		ov_memstack_unlock();
		KS_logfile_info(("%s: HandleRequest: Message not valid: no msg-Tag. Deleting Data.", this->v_identifier));
		return OV_ERR_BADVALUE;
	}
	if(Ov_Fail(acplt_simpleMsg_xml_getAttributeData(msgString, "msg", "hdrL", &tempData)))
	{
		ov_memstack_unlock();
		KS_logfile_info(("%s: HandleRequest: Message not valid: no hdrL Attribute. Deleting Data.", this->v_identifier));
		return OV_ERR_BADVALUE;
	}
	hdrLength = strtoul(tempData, NULL, 10);
	if(!hdrLength)
	{
		ov_memstack_unlock();
		KS_logfile_info(("%s: HandleRequest: Message not valid: hdrL 0 or not valid. Deleting Data.", this->v_identifier));
		return OV_ERR_BADVALUE;
	}
	if(Ov_Fail(acplt_simpleMsg_xml_getAttributeData(msgString, "msg", "bdyL", &tempData)))
	{
		ov_memstack_unlock();
		KS_logfile_info(("%s: HandleRequest: Message not valid: no bdyL Attribute. Deleting Data.", this->v_identifier));
		return OV_ERR_BADVALUE;
	}
	bdyLength = strtoul(tempData, NULL, 10);
	if(!bdyLength)
	{
		ov_memstack_unlock();
		KS_logfile_info(("%s: HandleRequest: Message not valid: bdyL 0 or not valid. Deleting Data.", this->v_identifier));
		return OV_ERR_BADVALUE;
	}
	/*	calculate msgLength: msg-Tag + header + body + "</msg>	*/
	msgLength = msgTagLength + hdrLength + bdyLength + 6;

	if((dataReceived->length - (dataReceived->readPT - dataReceived->data)) < msgLength)
	{	/*	not complete	*/
		ov_memstack_unlock();
		KS_logfile_debug(("%s: HandleRequest: Buffer does NOT hold the complete request. waiting some time...", this->v_identifier));
		pChannel->v_ConnectionTimeOut = 2;
		return OV_ERR_OK;		/*	get called again to process the request next time (if it is complete then).
															Yes, this could block the ClientHandler for a longer time.	*/
	}
	else
	{
		pChannel->v_ConnectionTimeOut = 120;
	}

	/***********************************************************************************************************************************************************************************************
	 * message is definitely complete
	 ***********************************************************************************************************************************************************************************************/

	/*	copy rest of message into temporary string and hand it over to the parse function. increment dataReceived->readPT	*/
	for(i=msgTagLength; i<msgLength; i++)
		msgString[i] = dataReceived->readPT[i];
	msgString[i] = '\0';
	dataReceived->readPT += i;

	MessageSys_parseAndDeliverMsg(msgString, &pNewMessage, &pInbox);
	if(pNewMessage && pInbox)
	{/*	fill in additional information	*/
		pNewMessage->v_sendBy = 0; /*	came directly	*/

		pChannel = Ov_GetParent(ksbase_AssocChannelClientHandler, this);
		if(pChannel)
		{
			/*	find "holdconnection"-variable, check type and value	*/
			InboxElem.elemtype = OV_ET_OBJECT;
			InboxElem.pobj = Ov_StaticPtrCast(ov_object, pInbox);
			ov_element_getnextpart(&InboxElem, &VarElem, OV_ET_VARIABLE);
			while(VarElem.elemtype != OV_ET_NONE)
			{
				if(VarElem.elemunion.pvar)
				{
					if((ov_string_comparei(VarElem.elemunion.pvar->v_identifier, "holdConnection") == OV_STRCMP_EQUAL)	/*	variable name matches	*/
						&& ((VarElem.elemunion.pvar->v_vartype | OV_VT_KSMASK) == OV_VT_BOOL)	/*	varType matches	*/
						&& (*((OV_BOOL*) VarElem.pvalue) == TRUE))	/*	we should hold the connection	*/
					{
						Ov_Link(MessageSys_Message2Channel, pNewMessage,  pChannel);
					}
					else
					{
						pChannel->v_CloseAfterSend = TRUE;
					}
				}
				ov_element_getnextpart(&InboxElem, &VarElem, OV_ET_VARIABLE);
			}
		}

	}

	ov_memstack_unlock();
    return OV_ERR_OK;
}

